{
    "collab_server" : "",
    "contents" : "#!/usr/bin/env R\n\n# for generic functions used often\n# ported from gen_sapt_efp.r\n# and scs_rad.r etc\n\n# IN PARTICULAR FOR SCS PROJECTS\n# functions copied from sapt_efp\n# will not be removed from original\n# scripts, instead don't create \n# separate copies in other SCS files\n\n# ONLY FUNCTIONS THAT WILL NOT BE ALTERED \n# FUNCTIONS LIKE coef.scs.fn WHICH WILL BE\n# TWEAKED FOR PARTICULAR PROJECTS AND PURPOSES\n# E.G. BOOTSTRAPPING, SHOULD BE LEFT IN THEIR\n# ORIGINAL SCRIPTS\n# THIS WAY, CHANGES TO THOSE FUNCTIONS WILL\n# NOT IMPACT OTHER PROJCETS\n\n# STILL UP IN THE AIR ABOUT THE BOOTSTRAP\n# FUNCTION, AS IT DOESN'T CHANGE MUCH \n\nclassic.stats <- function(x) {\n    c(mean = mean(x, na.rm = TRUE)\n      , med = median(x, na.rm = TRUE)\n      , sd = sd(x, na.rm = TRUE)\n      , min = min(x, na.rm = TRUE)\n      , max = max(x, na.rm = TRUE))\n}\n\n# mean average error\nmae <- function(x) {\n    mean(abs(x), na.rm = TRUE)\n}\n\n# gives mae, med, sd, min, max (min.name, max.name)\nbasic.stats <- function(x, iden = NULL) {\n    \n    if (missing(iden)) {\n        a = c(mae = mae(x)\n                 , med = median(x, na.rm = TRUE)\n                 , sd = sd(x, na.rm = TRUE),\n                 min = min(x, na.rm = TRUE)\n                 , max = max(x, na.rm = TRUE))\n    } else {\n        iden = as.list(iden)\n        a = c(mae = mae(x)\n                 , med = median(x, na.rm = TRUE)\n                 , sd = sd(x, na.rm = TRUE)\n                 , min = min(x, na.rm = TRUE)\n                 , max = max(x, na.rm = TRUE)\n                 , min.name = iden[which.min(x)]\n                 , max.name = iden[which.max(x)])\n    }\n    #return(as.list(a))\n    return(a)\n}\n\nmue.stats <- function(x, iden = NULL) {\n    if (missing(iden)) {\n        return(as.list(basic.stats(x)))\n    } else {\n        return(as.list(basic.stats(x = x, iden = iden)))\n    }\n}\n\n\n\n# gives mae, sd, max (max.name)\nbare.stats <- function(x, iden = NULL) {\n    # somehow need double square brackets to pick up number only\n    # otherwise rowname will show up in max column name\n    # not sure why this doesn't affect basic.stats\n    \n    if (missing(iden)) {\n        mymax = which.max(abs(x))\n        a = c(MAE = mae(x)\n                 , SD = sd(x, na.rm = TRUE)\n                 , Max = x[[mymax]])\n    } else {\n        iden = as.list(iden)\n        a = c(MAE = mae(x), SD = sd(x, na.rm = TRUE)\n                 , Max = x[[which.max(abs(x))]]\n                 , Max.Name = iden[which.max(abs(x))])\n    }\n    return(as.list(a))\n}\n\n# no median\nnomed.stats <- function(x) {\n    a = c(MAE = mae(x)\n          , SD = sd(x, na.rm = TRUE),\n          Min = min(x, na.rm = TRUE)\n          , Max = max(x, na.rm = TRUE))\n    return(a)\n}\n\n\n# from gen_sapt_efp.r\ncoef.simple.fn <- function(dt, x, y, iden.name = NULL) {\n    # expand dependent x's & construct formula\n    dep = paste(y, collapse = \" + \")\n    my.formula = paste(x, \" ~ \", dep, sep = \"\")\n    \n    m = lm(formula = my.formula, data = dt, na.action = na.exclude)\n    model = summary(m)\n    \n    coefficients = coef(m)\n    setNames(coefficients, names(coef(m)))\n    # return vector of interested values\n    #return(c(coef(model), adj_r2, basic.stats(resid(model))))\n    # model$adj.r.squared \n    if (missing(iden.name)) {\n        a = c(coefficients, \"R.sq\" = model$r.squared, basic.stats(resid(model)), n = nrow(dt))\n    } else {\n        a = c(coefficients, \"R.sq\" = model$r.squared, basic.stats(resid(model), iden.name), n = nrow(dt))\n    }\n    return(as.list(a))\n}\n\n\ncoef.stats.fn <- function(dt, x, y, iden.name = NULL) {\n    # expand dependent x's & construct formula\n    dep = paste(y, collapse = \" + \")\n    my.formula = paste(x, \" ~ \", dep, sep = \"\")\n    \n    model = summary(lm(formula = my.formula, data = dt, na.action = na.exclude))\n    \n    coefficients = coef(model)\n    # create vector of names for named list\n    coef.names = dimnames(coefficients)[1]\n    other.stats = c(\"coef\", \"stderr\", \"tval\", \"pval\")\n    l.n = c()\n    #coef.names = c(\"OS.ncp\", \"SS.ncp\")\n    for (i in other.stats) {\n        l.n = c(l.n, mapply(paste, coef.names, i, sep = \"_\"))\n    }\n    # flatten table\n    coefficients = c(coefficients)\n    # name the coefficients\n    names(coefficients) = l.n\n    # return vector of interested values\n    #return(c(coef(model), adj_r2, basic.stats(resid(model))))\n    # model$adj.r.squared \n    if (missing(iden.name)) {\n        a = c(coefficients, \"R.sq\" = model$r.squared, basic.stats(resid(model)), n = nrow(dt))\n    } else {\n        a = c(coefficients, \"R.sq\" = model$r.squared, basic.stats(resid(model), iden.name), n = nrow(dt))\n    }\n    return(as.list(a))\n}\n\nfast.stats <- c(\"OS.nonCP\", \"SS.nonCP\", \"MAE\", \"SD\", \"Min\", \"Max\")\n\nfast.coef.fn <- function(dt, indices, x, y) {\n    # indep and dep swapped, old mistake\n    dt = dt[indices, ]\n    tindep = data.matrix(dt[, x, with = F])\n    tdep = data.matrix(dt[, y, with = F])\n    \n    mod = lm.fit(x = tdep, y = tindep)\n    cc = mod$coefficients\n    \n    numbers = c(cc, nomed.stats(resid(mod)))\n    \n    #return(as.list(numbers))\n    return(numbers)\n}\n\npredict.fn <- function(dt, x, y) {\n    # copied from above\n    dep = paste(y, collapse = \" + \")\n    my.formula = paste(x, \" ~ \", dep, sep = \"\")\n    \n    model = lm(formula = my.formula, data = dt, na.action = na.exclude)\n    \n    return(data.table(predict(model, newdata = dt)))\n}\n\nscaled.fn <- function(dt, x, y, i) {\n    # assume no intercept, formula of form a + b + 0\n    # i is the name (specified in y) \n    # of the column to scale in dt\n    # it is a string, e.g. \"OS.ncp\"\n    dep = paste(y, collapse = \" + \")\n    my.formula = paste(x, \" ~ \", dep, sep = \"\")\n    \n    m = lm(formula = my.formula, data = dt, na.action = na.exclude)\n    \n    # column names in dt correspond to y\n    return(dt[, get(i) * coef(m)[i]])\n}\n\n# function to factorize integers\nfactor_integer <- function(x) {\n    x = as.integer(x)\n    div = seq_len(abs(x))\n    factors = div[x %% div == 0L]\n    factors = list(neg = -factors, pos = factors)\n    return(factors)\n}\n\n\n### ============= BOOTSTRAP FUNCTION =============== ###\n# copied from bootstrap.r from the sapt_efp.Rproj \n# function to generate  (99%) confidence intervals\n# NOTE: boot_comp takes in list of interested statistics and their positions returned by the statistic fn\n# paired tuple of names of statistic to bootstrap & it's position\nci.extract.fn <- function(dt, indep, dep, boot_comp, stat.fn) {\n    boot.out <- boot(data = dt, R = n_iter, statistic = stat.fn,\n                     x = indep, y = dep,\n                     parallel = \"multicore\", ncpus = 12)\n    n_stats = length(boot_comp)                     # number of statistics, length of first row\n    boot.stat.dt <- data.table(Component = as.factor(boot_comp), \n                               stat = vector(mode = \"numeric\", length = n_stats),\n                               lower = vector(mode = \"numeric\", length = n_stats),\n                               upper = vector(mode = \"numeric\", length = n_stats))\n    # get value, and upper and lower bounds of 95% confidence interval for interested stats\n    # output of boot.ci looks like\n    # t* mean sd min max\n    for (i in 1:n_stats) {\n        ### REMEMBER TO CHANGE CI.OUT$BCA/BASIC WHEN CHANGING TYPE!!! ###\n        ci.out <- boot.ci(boot.out, index = as.integer(i), type = \"basic\", conf = 0.99)\n        int_val <- c(ci.out$t0, ci.out$basic[4:5])  #can't use tail for some reason\n        boot.stat.dt[Component == boot_comp[i], c(\"stat\", \"lower\", \"upper\") := as.list(int_val)]\n    }\n    return(boot.stat.dt)\n}\n\nscs.bs.fn <- function(dt, indices, x, y) {\n    # SAPT (x) on vertical, EFP (y) taking on coefficient\n    # expand dependent x's & construct formula\n    dep = paste(y, collapse = \" + \")\n    my.formula = paste(x, \" ~ \", dep, sep = \"\")\n    \n    d = dt[indices, ]\n    \n    # using summary since resid() can extract residuals from both \n    # lm() and summary(lm())\n    # and other two groups need summary()\n    model <- summary(lm(formula = my.formula, data = d))\n    \n    return(c(coef(model), model$r.squared, basic.stats(resid(model))))\n}\n\nwide.ci.printfn <- function(dt) {\n    d = gather(data = dt, key = Stats, value = values, ... = stat:upper) \n    d$Component = factor(d$Component, levels = l.stats)\n    d$Stats = factor(d$Stats, levels = c(\"stat\", \"lower\", \"upper\"))\n    print(d)\n    d = unite(data = d, col = comp.stat, ... = c(Component, Stats), sep = \".\") %>%\n        spread(key = comp.stat, value = values) %>%\n        data.table()\n    return(d)\n}\n\ncollate <- function(a,b,c) {\n    # stat, lower and upper for CI data.table's\n    sprintf(\"% .3g, (% .3g, % .3g)\", a, b, c) \n}\n\nperc_err.fn <- function(dt, indep, dep) {\n    # calculates the percentage error\n    d = copy(dt)\n    d[, predEn := predict.fn(dt = .SD, x = indep, y = dep)]\n    a = d[, bare.stats(-100 * abs(corrEn - predEn) / corrEn)]\n    return(a)\n}\n\n# for plotting different conditions\n# zeroN and zeroA now that corrEn < -4 no longer used\n# function to match cond to appropriate title according to list given\ncond_to_title <- function(cond, inList) {\n    return(inList[[cond]])\n}\n\n# for plotting points side by side\n#dodge <- position_dodge(width = 0.02)\n\n# first written in \"perc_err.r\", appropriated here \n# since it's first mention is used here (Mon 02 May 2016)\ninterested <- c(\"os.coef\", \"ss.coef\", \"MAE\", \"SD\", \"Min\", \"Max\")\n\n\n# for plotting ci plots of the pointrange type\n# moved here from srs.r (Mon 02 May 2016)\nsrs.ci.pltfn <- function(dt, titleStr, ggsave.prefix) {\n    plt <- ggplot(data = dt[Component %in% interested]) +\n        geom_pointrange(aes(x = cutoff, y = stat, ymin = lower, ymax = upper, colour = r, shape = method)\n                        , position = dodge, size = 0.5) +\n        theme(axis.text.x = element_text(angle = 45, hjust = 1)) +\n        facet_grid(Component ~ basis, scales = \"free_y\") +\n        ggtitle(titleStr)\n    print(plt)\n    \n    ggsave(plot = plt, path = \"~/GoogleDrive/scs-it/images/cutoffs/\"\n           , filename = paste(ggsave.prefix, \".pdf\", sep = \"\")\n           , width = 12 ,height = 7)\n}",
    "created" : 1476161945878.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2514156392",
    "id" : "94787375",
    "lastKnownWriteTime" : 1476161987,
    "last_content_update" : 1476161987279,
    "path" : "~/GoogleDrive/Zoe-Sam/soot/scripts/gen_func.r",
    "project_path" : "scripts/gen_func.r",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}